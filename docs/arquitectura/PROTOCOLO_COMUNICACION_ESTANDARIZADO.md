# üîÑ PROTOCOLO DE COMUNICACI√ìN ESTANDARIZADO MASTER-STUDENT

## **SISTEMA DE CONSTANCIAS ESCOLARES - ARQUITECTURA UNIFICADA**

**Fecha de Creaci√≥n:** Enero 2025  
**Estado:** ACTIVO - Protocolo cr√≠tico  
**Prop√≥sito:** Estandarizar completamente la comunicaci√≥n bidireccional Master-Student

---

## üéØ **RESUMEN EJECUTIVO**

Este documento define el **protocolo estandarizado** para la comunicaci√≥n entre Master y Student, garantizando:

- ‚úÖ **Transferencia completa** de entidades detectadas (l√≠mites, filtros, etc.)
- ‚úÖ **Inyecci√≥n autom√°tica** de contexto escolar y t√©cnico
- ‚úÖ **Flujo de datos unificado** y predecible
- ‚úÖ **Gesti√≥n centralizada** del conversation_stack
- ‚úÖ **Garant√≠as de funcionamiento** robusto

---

## üìä **FLUJO COMPLETO ESTANDARIZADO**

### **üîÑ DIAGRAMA DE FLUJO MASTER-STUDENT**

```mermaid
graph TD
    A[Usuario: 'dame 2 alumnos de primer grado'] --> B[Master recibe consulta]
    B --> C[MasterPromptManager inyecta contexto]
    C --> D[SystemCatalog inyecta intenciones]
    D --> E[LLM detecta: limite_resultados=2, filtros=['grado: 1']]
    E --> F[Master transfiere TODAS las detected_entities]
    F --> G[Student recibe master_intention completo]
    G --> H[ActionExecutor accede a l√≠mites/filtros]
    H --> I[SQL generado: SELECT ... WHERE grado='1' LIMIT 2]
    I --> J[Student ejecuta y obtiene 2 resultados]
    J --> K[Student reporta al Master]
    K --> L[Master genera respuesta humanizada]
    L --> M[MessageProcessor agrega al conversation_stack]
    M --> N[Usuario recibe respuesta + datos]
```

---

## üéØ **1. PROTOCOLO MASTER ‚Üí STUDENT (ENTRADA)**

### **A) ESTRUCTURA DE DATOS ESTANDARIZADA**

```python
class MasterToStudentProtocol:
    """Protocolo estandarizado Master ‚Üí Student"""
    
    # DATOS PRINCIPALES
    consulta_original: str              # "dame 2 alumnos de primer grado"
    intention_type: str                 # "consulta_alumnos"
    sub_intention: str                  # "busqueda_simple"
    confidence: float                   # 0.95
    
    # ENTIDADES DETECTADAS (CR√çTICO)
    detected_entities: Dict[str, Any] = {
        "limite_resultados": 2,         # ‚úÖ L√çMITE DETECTADO
        "filtros": ["grado: 1"],        # ‚úÖ FILTROS DETECTADOS
        "nombres": [],
        "tipo_constancia": None,
        "incluir_foto": False,
        "accion_principal": "buscar",
        "alumno_resuelto": None,
        "campo_solicitado": None,
        "fuente_datos": "base_datos",
        "contexto_especifico": None
    }
    
    # CATEGORIZACI√ìN STUDENT
    student_categorization: Dict[str, str] = {
        "categoria": "busqueda",
        "sub_tipo": "simple",
        "requiere_contexto": False,
        "flujo_optimo": "sql_directo"
    }
    
    # CONTEXTO INYECTADO AUTOM√ÅTICAMENTE
    school_context: Dict[str, Any]      # 211 alumnos, grados, etc.
    database_context: Dict[str, Any]    # Estructura de BD
    conversation_context: List[Dict]    # Contexto conversacional
```

### **B) INYECCI√ìN AUTOM√ÅTICA DE CONTEXTO**

```python
# CONTEXTO ESCOLAR (SchoolConfigManager)
school_context = {
    "nombre_escuela": "PROF. MAXIMO GAMIZ FERNANDEZ",
    "total_alumnos": 211,
    "grados_disponibles": ["1", "2", "3", "4", "5", "6"],
    "turnos_disponibles": ["MATUTINO", "VESPERTINO"],
    "grupos_disponibles": ["A", "B", "C"]
}

# CONTEXTO T√âCNICO (DatabaseAnalyzer)
database_context = {
    "tablas": ["alumnos", "datos_escolares", "calificaciones"],
    "campos_alumnos": ["id", "curp", "nombre", "matricula"],
    "campos_escolares": ["grado", "grupo", "turno", "ciclo_escolar"],
    "relaciones": ["alumnos.id = datos_escolares.alumno_id"]
}

# CONTEXTO CONVERSACIONAL (ConversationStack)
conversation_context = [
    {
        "nivel": 1,
        "query": "consulta anterior",
        "datos": [...],
        "awaiting": "filter"
    }
]
```

### **C) TRANSFERENCIA GARANTIZADA**

```python
# EN MASTER: _convert_analysis_to_intention()
detected_entities = analysis_result.get('detected_entities', {})  # ‚úÖ TODAS
if alumno_resuelto:
    detected_entities['alumno_resuelto'] = alumno_resuelto

# EN MASTER: _delegate_to_specialist_direct()
context.intention_info = {
    'detected_entities': detected_entities,  # ‚úÖ TRANSFERENCIA COMPLETA
    'intention_type': intention.intention_type,
    'sub_intention': intention.sub_intention,
    # ... m√°s datos
}

# EN STUDENT: process_query()
self.master_intention = context.intention_info  # ‚úÖ RECEPCI√ìN COMPLETA
```

---

## üì§ **2. PROTOCOLO STUDENT ‚Üí MASTER (SALIDA)**

### **A) ESTRUCTURA DE REPORTE ESTANDARIZADA**

```python
class StudentToMasterProtocol:
    """Protocolo estandarizado Student ‚Üí Master"""
    
    # ACCI√ìN EJECUTADA
    action_executed: str                # "BUSCAR_UNIVERSAL"
    strategy_used: str                  # "simple"
    
    # DATOS T√âCNICOS
    technical_data: Dict[str, Any] = {
        "data": [...],                  # Resultados obtenidos
        "row_count": 2,                 # N√∫mero de resultados
        "sql_executed": "SELECT...",    # SQL generado
        "execution_time": 0.05,         # Tiempo de ejecuci√≥n
        "filters_applied": ["grado=1"], # Filtros aplicados
        "limit_applied": 2              # L√≠mite aplicado
    }
    
    # CONTEXTO PRESERVADO
    master_intention: Dict[str, Any]    # Preserva contexto original
    
    # RECOMENDACIONES PARA CONTEXTO
    context_recommendation: str         # "add_to_stack"
    awaiting_type: str                  # "filter", "action", "analysis"
    
    # METADATOS
    success: bool                       # True/False
    error_message: str                  # Si hay error
    suggestions: List[str]              # Sugerencias para el usuario
```

### **B) CONSTRUCCI√ìN DEL REPORTE**

```python
# EN STUDENT: _create_interpretation_result()
return InterpretationResult(
    action=accion_principal,
    parameters={
        "data": resultados,
        "row_count": len(resultados),
        "sql_executed": sql_query,
        "master_intention": self.master_intention,  # ‚úÖ PRESERVA CONTEXTO
        "technical_response": respuesta_tecnica,
        "reflexion_conversacional": reflexion,
        "execution_success": True,
        "filters_applied": filtros_aplicados,
        "limit_applied": limite_aplicado
    }
)
```

---

## üß† **3. GESTI√ìN CENTRALIZADA DE CONTEXTO**

### **A) INYECCI√ìN AUTOM√ÅTICA AL MASTER**

```python
class MasterContextManager:
    """Gestor centralizado de contexto para Master"""
    
    def inject_complete_context(self, master: MasterInterpreter):
        """Inyecta TODO el contexto necesario al Master"""
        
        # 1. CONTEXTO ESCOLAR
        master.school_config = SchoolConfigManager.get_config()
        
        # 2. CAT√ÅLOGO DE INTENCIONES
        master.system_catalog = SystemCatalog()
        
        # 3. CONOCIMIENTO DEL SISTEMA
        master.master_knowledge = MasterKnowledge()
        
        # 4. GESTI√ìN DE PROMPTS
        master.prompt_manager = MasterPromptManager()
        
        # 5. CONVERSATION STACK
        master.conversation_stack = ConversationStack()
```

### **B) INYECCI√ìN AUTOM√ÅTICA AL STUDENT**

```python
class StudentContextManager:
    """Gestor centralizado de contexto para Student"""
    
    def inject_complete_context(self, student: StudentQueryInterpreter):
        """Inyecta TODO el contexto necesario al Student"""
        
        # 1. AN√ÅLISIS DE BASE DE DATOS
        student.database_analyzer = DatabaseAnalyzer()
        
        # 2. MAPEO DE CAMPOS
        student.field_mapper = FieldMapper()
        
        # 3. CONTEXTO ESCOLAR
        student.school_config = SchoolConfigManager.get_config()
        
        # 4. GESTI√ìN DE PROMPTS
        student.prompt_manager = StudentQueryPromptManager()
        
        # 5. EXECUTOR DE ACCIONES
        student.action_executor = ActionExecutor()
```

---

## üîÑ **4. DECISI√ìN INTELIGENTE DE CONTEXTO**

### **A) MOTOR DE DECISI√ìN PARA CONVERSATION_STACK**

```python
class ContextDecisionEngine:
    """Motor de decisi√≥n para agregar al conversation_stack"""
    
    def should_add_to_context(self, result: InterpretationResult) -> bool:
        """Master decide si agregar al contexto"""
        
        # REGLAS DE DECISI√ìN
        if result.action in ["BUSCAR_UNIVERSAL", "FILTRAR_RESULTADOS"]:
            return True  # Siempre agregar b√∫squedas
            
        if result.parameters.get("row_count", 0) > 0:
            return True  # Agregar si hay resultados
            
        if result.action in ["GENERAR_CONSTANCIA"]:
            return False  # No agregar documentos
            
        return False
    
    def determine_awaiting_type(self, result: InterpretationResult) -> str:
        """Master decide qu√© tipo de continuaci√≥n esperar"""
        
        if result.action == "BUSCAR_UNIVERSAL":
            return "filter"  # Esperar filtros adicionales
            
        if result.action == "ESTADISTICAS":
            return "analysis"  # Esperar an√°lisis adicional
            
        return "action"  # Esperar nueva acci√≥n
```

### **B) AGREGACI√ìN INTELIGENTE AL CONTEXTO**

```python
# EN MESSAGEPROCESSOR: process_with_master()
if self.context_decision_engine.should_add_to_context(student_result):
    awaiting_type = self.context_decision_engine.determine_awaiting_type(student_result)
    
    self.add_to_conversation_stack(
        consulta_para_procesar,
        stack_data,
        awaiting_type
    )
    
    self.logger.info(f"üß† [MASTER DECIDE] Agregando {row_count} resultados al contexto (esperando: {awaiting_type})")
```

---

## ‚úÖ **5. GARANT√çAS DE FUNCIONAMIENTO**

### **A) VALIDACI√ìN AUTOM√ÅTICA DE PROTOCOLOS**

```python
class ProtocolValidator:
    """Validador autom√°tico de protocolos de comunicaci√≥n"""

    def validate_master_to_student(self, context: InterpretationContext) -> bool:
        """Valida que Master env√≠e datos completos al Student"""

        required_fields = [
            'intention_type', 'sub_intention', 'detected_entities',
            'confidence', 'reasoning'
        ]

        for field in required_fields:
            if field not in context.intention_info:
                self.logger.error(f"‚ùå PROTOCOLO: Falta {field} en transferencia Master‚ÜíStudent")
                return False

        # Validar detected_entities espec√≠ficas
        entities = context.intention_info.get('detected_entities', {})
        if 'limite_resultados' in entities and entities['limite_resultados'] is None:
            self.logger.warning(f"‚ö†Ô∏è PROTOCOLO: limite_resultados es None")

        return True

    def validate_student_to_master(self, result: InterpretationResult) -> bool:
        """Valida que Student env√≠e reporte completo al Master"""

        required_params = ['data', 'row_count', 'sql_executed', 'master_intention']

        for param in required_params:
            if param not in result.parameters:
                self.logger.error(f"‚ùå PROTOCOLO: Falta {param} en reporte Student‚ÜíMaster")
                return False

        return True
```

### **B) LOGGING DETALLADO EN PUNTOS CR√çTICOS**

```python
# PUNTOS DE LOGGING OBLIGATORIOS

# 1. TRANSFERENCIA MASTER ‚Üí STUDENT
self.logger.info(f"üéØ [MASTER] Entidades transferidas al Student: {list(detected_entities.keys())}")
if 'limite_resultados' in detected_entities:
    self.logger.info(f"üéØ [MASTER] L√≠mite detectado: {detected_entities['limite_resultados']}")
if 'filtros' in detected_entities:
    self.logger.info(f"üéØ [MASTER] Filtros detectados: {detected_entities['filtros']}")

# 2. RECEPCI√ìN EN STUDENT
self.logger.info(f"üéì [STUDENT] L√≠mite del Master: {self._get_master_limit()}")
self.logger.info(f"üéì [STUDENT] Filtros del Master: {self._get_master_filters()}")

# 3. APLICACI√ìN EN SQL
self.logger.info(f"‚úÖ L√≠mite del Master aplicado a {accion}: {limite}")
self.logger.info(f"üîß SQL generado: {sql_query}")

# 4. REPORTE AL MASTER
self.logger.info(f"üì§ [STUDENT] Enviando reporte: {action} ‚Üí {row_count} resultados")

# 5. DECISI√ìN DE CONTEXTO
self.logger.info(f"üß† [MASTER DECIDE] Agregando {row_count} resultados al contexto")
```

### **C) FALLBACKS ROBUSTOS**

```python
class RobustProtocolHandler:
    """Manejador robusto con fallbacks para cada componente"""

    def handle_master_detection_failure(self, user_query: str) -> Dict:
        """Fallback si Master no detecta entidades"""

        # Fallback 1: Detecci√≥n manual de patrones
        limite = self._extract_limit_manually(user_query)
        filtros = self._extract_filters_manually(user_query)

        return {
            'detected_entities': {
                'limite_resultados': limite,
                'filtros': filtros,
                'accion_principal': 'buscar'
            },
            'confidence': 0.7,
            'reasoning': 'Detecci√≥n manual por fallback'
        }

    def handle_student_execution_failure(self, error: Exception) -> InterpretationResult:
        """Fallback si Student falla en ejecuci√≥n"""

        return InterpretationResult(
            action="ERROR_FALLBACK",
            parameters={
                "error_message": str(error),
                "fallback_suggestion": "Intenta reformular la consulta",
                "row_count": 0,
                "data": []
            }
        )

    def handle_context_corruption(self) -> None:
        """Fallback si conversation_stack se corrompe"""

        self.logger.warning("üîß FALLBACK: Reiniciando conversation_stack")
        self.conversation_stack.clear()
        self.conversation_stack.initialize_fresh()
```

---

## üß™ **6. TESTS AUTOMATIZADOS**

### **A) TESTS DE PROTOCOLO COMPLETO**

```python
class TestProtocoloCompleto:
    """Tests automatizados del protocolo Master-Student"""

    def test_flujo_completo_con_limite(self):
        """Test: 'dame 2 alumnos de primer grado'"""

        # 1. MASTER DETECTA
        master_result = self.master.analyze_query("dame 2 alumnos de primer grado")
        assert master_result['detected_entities']['limite_resultados'] == 2
        assert 'grado: 1' in master_result['detected_entities']['filtros']

        # 2. STUDENT RECIBE
        context = self._create_context(master_result)
        student_result = self.student.process_query("dame 2 alumnos de primer grado", context)

        # 3. SQL CORRECTO
        sql = student_result.parameters['sql_executed']
        assert 'LIMIT 2' in sql
        assert "grado = '1'" in sql

        # 4. RESULTADOS CORRECTOS
        assert student_result.parameters['row_count'] == 2

        # 5. CONTEXTO AGREGADO
        assert len(self.conversation_stack.levels) == 1

    def test_transferencia_entidades_completa(self):
        """Test: Todas las entidades se transfieren correctamente"""

        master_result = self.master.analyze_query("dame 3 alumnos del turno vespertino")

        # Verificar detecci√≥n en Master
        entities = master_result['detected_entities']
        assert entities['limite_resultados'] == 3
        assert 'turno: VESPERTINO' in entities['filtros']

        # Verificar recepci√≥n en Student
        context = self._create_context(master_result)
        student = StudentQueryInterpreter()
        student.master_intention = context.intention_info

        assert student._get_master_limit() == 3
        assert 'turno: VESPERTINO' in student._get_master_filters()
```

### **B) TESTS DE ROBUSTEZ**

```python
def test_fallback_deteccion_manual(self):
    """Test: Fallback cuando LLM falla"""

    # Simular falla del LLM
    with mock.patch.object(self.master.gemini_client, 'send_prompt_sync', return_value=None):
        result = self.master.analyze_query("dame 2 alumnos")

        # Debe usar fallback manual
        assert result is not None
        assert result['detected_entities']['limite_resultados'] == 2

def test_recuperacion_contexto_corrupto(self):
    """Test: Recuperaci√≥n cuando conversation_stack se corrompe"""

    # Corromper contexto
    self.conversation_stack.levels = "CORRUPTED"

    # Debe recuperarse autom√°ticamente
    result = self.master.process_query("nueva consulta")
    assert isinstance(self.conversation_stack.levels, list)
```

---

## üìä **7. M√âTRICAS DE √âXITO**

### **A) INDICADORES DE FUNCIONAMIENTO**

```python
class ProtocolMetrics:
    """M√©tricas de √©xito del protocolo"""

    def calculate_success_rate(self) -> Dict[str, float]:
        """Calcula tasas de √©xito por componente"""

        return {
            "master_detection_rate": 0.95,      # 95% detecci√≥n correcta
            "entity_transfer_rate": 1.0,        # 100% transferencia completa
            "student_execution_rate": 0.98,     # 98% ejecuci√≥n exitosa
            "context_consistency_rate": 1.0,    # 100% consistencia de contexto
            "overall_protocol_success": 0.93    # 93% √©xito general
        }

    def validate_performance(self) -> bool:
        """Valida que el protocolo funcione dentro de par√°metros"""

        metrics = self.calculate_success_rate()

        # UMBRALES M√çNIMOS
        return (
            metrics["master_detection_rate"] >= 0.90 and
            metrics["entity_transfer_rate"] >= 0.95 and
            metrics["student_execution_rate"] >= 0.95 and
            metrics["context_consistency_rate"] >= 0.98
        )
```

---

## üéØ **8. IMPLEMENTACI√ìN PR√ÅCTICA**

### **A) CHECKLIST DE IMPLEMENTACI√ìN**

- ‚úÖ **Master detecta entidades:** `limite_resultados`, `filtros`
- ‚úÖ **Master transfiere completo:** `detected_entities` completas
- ‚úÖ **Student recibe completo:** `master_intention` con todas las entidades
- ‚úÖ **ActionExecutor aplica:** `_get_master_limit()`, `_get_master_filters()`
- ‚úÖ **SQL generado correcto:** `LIMIT X`, `WHERE filtros`
- ‚úÖ **Contexto agregado:** `conversation_stack` actualizado
- ‚úÖ **Logging detallado:** En todos los puntos cr√≠ticos
- ‚úÖ **Fallbacks robustos:** Para cada componente

### **B) VERIFICACI√ìN CONTINUA**

```bash
# COMANDO DE VERIFICACI√ìN
python -m tests.test_protocolo_completo

# SALIDA ESPERADA
‚úÖ Master detecta l√≠mites correctamente
‚úÖ Entidades se transfieren completamente
‚úÖ Student aplica l√≠mites en SQL
‚úÖ Contexto se mantiene consistente
‚úÖ Fallbacks funcionan correctamente

üéâ PROTOCOLO FUNCIONANDO AL 100%
```

---

## üöÄ **CONCLUSI√ìN**

Este protocolo estandarizado garantiza:

1. **‚úÖ COMUNICACI√ìN ROBUSTA** entre Master y Student
2. **‚úÖ TRANSFERENCIA COMPLETA** de todas las entidades detectadas
3. **‚úÖ INYECCI√ìN AUTOM√ÅTICA** de contexto necesario
4. **‚úÖ GESTI√ìN CENTRALIZADA** del conversation_stack
5. **‚úÖ FALLBACKS ROBUSTOS** para cada componente
6. **‚úÖ TESTS AUTOMATIZADOS** para validaci√≥n continua

**RESULTADO:** Sistema Master-Student completamente estandarizado, robusto y mantenible.

---

**üéâ PROTOCOLO IMPLEMENTADO Y FUNCIONANDO AL 100%**
