"""
Formateador de respuestas para mejorar la presentaci√≥n visual
Convierte texto plano en HTML con formato atractivo
"""

import re
from typing import Dict, List
from app.ui.styles import theme_manager


class ResponseFormatter:
    """
    üé® FORMATEADOR UNIVERSAL DE RESPUESTAS V2.0

    CARACTER√çSTICAS MEJORADAS:
    - Formateo autom√°tico inteligente de CUALQUIER texto
    - Detecci√≥n autom√°tica del tipo de contenido
    - Estilos consistentes y profesionales
    - Soporte completo para markdown y texto plano
    - Formateo especializado por contexto
    """

    def __init__(self):
        # üéØ USAR THEMEMANAGER CENTRALIZADO para estilos
        self.styles = theme_manager.get_response_formatter_styles()

        # üÜï PATRONES DE DETECCI√ìN AUTOM√ÅTICA
        self.content_patterns = {
            'student_list': [r'\d+\.\s+[A-Z√Å√â√ç√ì√ö√ë\s]+', r'CURP:', r'üìã', r'üéì'],
            'help_content': [r'\*\*.*?\*\*', r'¬ø.*\?', r'üí°', r'üìö', r'‚ÑπÔ∏è'],
            'statistics': [r'\d+\s+(alumnos?|estudiantes?)', r'Total:', r'üìä', r'üìà'],
            'error_message': [r'‚ùå', r'Error', r'No se pudo', r'‚ö†Ô∏è'],
            'success_message': [r'‚úÖ', r'√âxito', r'Generado', r'Completado'],
            'constancia_info': [r'constancia', r'PDF', r'generado', r'archivo'],
            'greeting': [r'¬°Hola!', r'Bienvenido', r'Es un gusto', r'saludarte']
        }

    def format_response(self, text: str, response_type: str = "auto") -> str:
        """
        üé® FORMATEA CUALQUIER RESPUESTA CON DETECCI√ìN AUTOM√ÅTICA

        Args:
            text: Texto a formatear
            response_type: Tipo de respuesta ("auto" para detecci√≥n autom√°tica)

        Returns:
            HTML formateado profesionalmente
        """
        try:
            # üîç DETECCI√ìN AUTOM√ÅTICA SI NO SE ESPECIFICA TIPO
            if response_type == "auto" or response_type == "general":
                response_type = self._detect_content_type(text)

            # üéØ APLICAR FORMATEO ESPEC√çFICO
            if response_type == "help":
                return self._format_help_response(text)
            elif response_type == "data" or response_type == "student_list":
                return self._format_data_response(text)
            elif response_type == "error":
                return self._format_error_response(text)
            elif response_type == "success":
                return self._format_success_response(text)
            elif response_type == "statistics":
                return self._format_statistics_response(text)
            elif response_type == "greeting":
                return self._format_greeting_response(text)
            else:
                return self._format_enhanced_general_response(text)

        except Exception as e:
            # En caso de error, aplicar formateo b√°sico
            return self._format_enhanced_general_response(text)

    def _detect_content_type(self, text: str) -> str:
        """üîç DETECTA AUTOM√ÅTICAMENTE EL TIPO DE CONTENIDO"""
        # Contar coincidencias para cada tipo
        type_scores = {}

        for content_type, patterns in self.content_patterns.items():
            score = 0
            for pattern in patterns:
                matches = len(re.findall(pattern, text, re.IGNORECASE))
                score += matches
            type_scores[content_type] = score

        # Retornar el tipo con mayor puntuaci√≥n
        if type_scores:
            best_type = max(type_scores, key=type_scores.get)
            if type_scores[best_type] > 0:
                return best_type

        return "general"

    def _format_help_response(self, text: str) -> str:
        """Formatea respuestas de ayuda usando configuraci√≥n centralizada"""
        # Convertir listas con vi√±etas
        text = self._convert_bullet_lists(text)

        # Convertir t√≠tulos con **
        text = self._convert_bold_titles(text)

        # üéØ USAR CONFIGURACI√ìN CENTRALIZADA PARA WRAPPERS
        if self.styles.get('enable_wrappers', False):
            return f"""
            <div style="{self.styles['help_border']}
                        padding: {self.styles['wrapper_padding']};
                        margin: {self.styles['wrapper_margin']};">
                <div style="font-size: {self.styles['font_size']}; line-height: {self.styles['line_height']};">
                    {text}
                </div>
            </div>
            """
        else:
            # üéØ SIN WRAPPER - SOLO TEXTO LIMPIO
            return text

    def _format_data_response(self, text: str) -> str:
        """üìä FORMATEA RESPUESTAS CON DATOS usando configuraci√≥n centralizada"""
        # üîß APLICAR FORMATEO MARKDOWN COMPLETO
        text = self._convert_bold_titles(text)
        text = self._convert_bullet_lists(text)
        text = self._enhance_emojis(text)
        text = self._highlight_important_info(text)
        text = self._highlight_numbers(text)

        # üéØ USAR CONFIGURACI√ìN CENTRALIZADA PARA WRAPPERS
        if self.styles.get('enable_wrappers', False):
            return f"""
            <div style="{self.styles['data_border']}
                        padding: {self.styles['wrapper_padding']};
                        margin: {self.styles['wrapper_margin']};">
                <div style="font-size: {self.styles['font_size']}; line-height: {self.styles['line_height']};">
                    {text}
                </div>
            </div>
            """
        else:
            # üéØ SIN WRAPPER - SOLO TEXTO LIMPIO (DataDisplayManager ya formatea bien)
            return text

    def _format_error_response(self, text: str) -> str:
        """Formatea respuestas de error usando configuraci√≥n centralizada"""
        # üéØ USAR CONFIGURACI√ìN CENTRALIZADA PARA WRAPPERS
        if self.styles.get('enable_wrappers', False):
            return f"""
            <div style="{self.styles['error_border']}
                        padding: {self.styles['wrapper_padding']};
                        margin: {self.styles['wrapper_margin']};">
                <div style="font-size: {self.styles['font_size']}; line-height: {self.styles['line_height']};">
                    {text}
                </div>
            </div>
            """
        else:
            return text

    def _format_success_response(self, text: str) -> str:
        """Formatea respuestas de √©xito usando configuraci√≥n centralizada"""
        # üéØ USAR CONFIGURACI√ìN CENTRALIZADA PARA WRAPPERS
        if self.styles.get('enable_wrappers', False):
            return f"""
            <div style="{self.styles['success_border']}
                        padding: {self.styles['wrapper_padding']};
                        margin: {self.styles['wrapper_margin']};">
                <div style="font-size: {self.styles['font_size']}; line-height: {self.styles['line_height']};">
                    {text}
                </div>
            </div>
            """
        else:
            return text

    def _format_enhanced_general_response(self, text: str) -> str:
        """üé® FORMATEA RESPUESTAS GENERALES usando configuraci√≥n centralizada"""
        # Aplicar todas las mejoras de formateo
        text = self._convert_bullet_lists(text)
        text = self._convert_bold_titles(text)
        text = self._enhance_emojis(text)
        text = self._improve_spacing(text)
        text = self._highlight_important_info(text)

        # üéØ USAR CONFIGURACI√ìN CENTRALIZADA PARA WRAPPERS
        if self.styles.get('enable_wrappers', False):
            return f"""
            <div style="font-size: {self.styles['font_size']};
                        line-height: {self.styles['line_height']};
                        padding: {self.styles['wrapper_padding']};
                        margin: {self.styles['wrapper_margin']};">
                {text}
            </div>
            """
        else:
            return text

    def _format_statistics_response(self, text: str) -> str:
        """üìä FORMATEA RESPUESTAS CON ESTAD√çSTICAS usando configuraci√≥n centralizada"""
        text = self._highlight_numbers(text)
        text = self._convert_bullet_lists(text)
        text = self._enhance_emojis(text)

        # üéØ USAR CONFIGURACI√ìN CENTRALIZADA PARA WRAPPERS
        if self.styles.get('enable_wrappers', False):
            return f"""
            <div style="{self.styles['data_border']}
                        padding: {self.styles['wrapper_padding']};
                        margin: {self.styles['wrapper_margin']};">
                <div style="font-size: {self.styles['font_size']}; line-height: {self.styles['line_height']};">
                    {text}
                </div>
            </div>
            """
        else:
            return text

    def _format_greeting_response(self, text: str) -> str:
        """üëã FORMATEA MENSAJES DE BIENVENIDA usando configuraci√≥n centralizada"""
        text = self._convert_bullet_lists(text)
        text = self._convert_bold_titles(text)
        text = self._enhance_emojis(text)
        text = self._improve_spacing(text)

        # üéØ USAR CONFIGURACI√ìN CENTRALIZADA PARA WRAPPERS
        if self.styles.get('enable_wrappers', False):
            return f"""
            <div style="{self.styles['success_border']}
                        padding: {self.styles['wrapper_padding']};
                        margin: {self.styles['wrapper_margin']};">
                <div style="font-size: {self.styles['font_size']}; line-height: {self.styles['line_height']};">
                    {text}
                </div>
            </div>
            """
        else:
            return text



    def _convert_bullet_lists(self, text: str) -> str:
        """Convierte listas con * en HTML SIN sobrescribir colores del ChatBubble"""
        lines = text.split('\n')
        in_list = False
        result = []

        for line in lines:
            stripped = line.strip()
            # üéØ NO CONVERTIR L√çNEAS QUE YA TIENEN FORMATO DE N√öMERO (ej: **1.** NOMBRE)
            if stripped.startswith('*') and not re.match(r'\*\*\d+\.\*\*', stripped):
                if not in_list:
                    result.append('<ul style="margin: 15px 0; padding-left: 25px; list-style-type: none;">')
                    in_list = True

                item_text = stripped[1:].strip()
                # üéØ SIN colores espec√≠ficos - usar inherit para respetar ChatBubble
                item_text = re.sub(r'\*\*(.*?)\*\*', r'<strong>\1</strong>', item_text)
                result.append(f'<li style="margin: 8px 0; position: relative; padding-left: 20px;"><span style="position: absolute; left: 0; opacity: 0.7;">‚Ä¢</span>{item_text}</li>')
            else:
                if in_list:
                    result.append('</ul>')
                    in_list = False
                result.append(line)

        if in_list:
            result.append('</ul>')

        return '\n'.join(result)

    def _convert_bold_titles(self, text: str) -> str:
        """Convierte texto en **negrita** a HTML simple SIN estilos inline problem√°ticos"""
        # üéØ USAR <strong> EN LUGAR DE <h4> PARA EVITAR SALTOS DE L√çNEA
        text = re.sub(
            r'\*\*(.*?)\*\*',
            r'<strong>\1</strong>',
            text
        )
        return text

    def _highlight_numbers(self, text: str) -> str:
        """Resalta n√∫meros importantes usando estilos centralizados"""
        # üéØ USAR ESTILOS CENTRALIZADOS
        text = re.sub(
            r'\b(\d{2,})\b',
            rf'<span style="{self.styles["number_highlight"]} font-weight: bold;">\1</span>',
            text
        )
        return text

    def _enhance_emojis(self, text: str) -> str:
        """Mejora la presentaci√≥n de emojis SIN sobrescribir colores del ChatBubble"""
        # üéØ Solo mejorar tama√±o y espaciado, SIN colores espec√≠ficos
        emojis = ['üîç', 'üìä', 'üìÑ', 'üîÑ', 'üí¨', 'üÜò', '‚úÖ', '‚ùå', '‚ö†Ô∏è']

        for emoji in emojis:
            if emoji in text:
                text = text.replace(
                    emoji,
                    f'<span style="font-size: 18px; margin-right: 5px;">{emoji}</span>'
                )
        return text

    def _improve_spacing(self, text: str) -> str:
        """üé® MEJORA EL ESPACIADO DEL TEXTO"""
        # Agregar espacios despu√©s de puntos seguidos de may√∫scula
        text = re.sub(r'\.([A-Z√Å√â√ç√ì√ö√ë])', r'. \1', text)

        # Mejorar espaciado alrededor de emojis
        text = re.sub(r'([üìäüìãüéìüîçüë•üí°‚úÖ‚ùå‚ö†Ô∏è])([A-Za-z])', r'\1 \2', text)
        text = re.sub(r'([A-Za-z])([üìäüìãüéìüîçüë•üí°‚úÖ‚ùå‚ö†Ô∏è])', r'\1 \2', text)

        # Limpiar espacios m√∫ltiples
        text = re.sub(r'\s+', ' ', text)

        return text

    def _highlight_important_info(self, text: str) -> str:
        """üéØ RESALTA INFORMACI√ìN IMPORTANTE"""
        # üîß SIMPLIFICAR RESALTADO DE CURPs (sin CSS complejo)
        text = re.sub(
            r'\b([A-Z]{4}\d{6}[HM][A-Z]{5}[A-Z0-9]\d)\b',
            r'<code>\1</code>',
            text
        )

        # üîß SIMPLIFICAR RESALTADO DE MATR√çCULAS (sin CSS complejo)
        text = re.sub(
            r'\b([A-Z]{4}-\d{6}-[A-Z0-9]{3})\b',
            r'<code>\1</code>',
            text
        )

        # Resaltar grados y grupos
        text = re.sub(
            r'\b(\d+¬∞\s+[A-Z])\b',
            r'<span style="font-weight: bold; opacity: 0.9;">\1</span>',
            text
        )

        return text

    @staticmethod
    def format_any_response(text: str) -> str:
        """
        üé® M√âTODO EST√ÅTICO UNIVERSAL PARA FORMATEAR CUALQUIER RESPUESTA

        Este m√©todo puede ser llamado desde cualquier parte del sistema
        para garantizar formateo consistente de todas las respuestas.

        Args:
            text: Cualquier texto a formatear

        Returns:
            HTML formateado profesionalmente
        """
        formatter = ResponseFormatter()
        return formatter.format_response(text, "auto")

    def format_student_list(self, students: List[Dict], title: str = "Resultados") -> str:
        """Formatea lista de estudiantes de manera atractiva"""
        if not students:
            return '<div style="color: #6c757d; font-style: italic;">No se encontraron estudiantes.</div>'

        html = f"""
        <div style="background-color: #f8f9fa; border-radius: 10px; padding: 20px; margin: 15px 0;">
            <h3 style="color: #495057; margin-top: 0; margin-bottom: 15px; font-size: 18px;">
                üìã {title} ({len(students)} estudiante{'s' if len(students) != 1 else ''})
            </h3>
            <div style="display: grid; gap: 10px;">
        """

        for i, student in enumerate(students, 1):
            nombre = student.get('nombre', 'N/A')
            grado = student.get('grado', 'N/A')
            grupo = student.get('grupo', 'N/A')
            turno = student.get('turno', 'N/A')

            html += f"""
            <div style="background-color: white; border: 1px solid #dee2e6; border-radius: 8px;
                        padding: 12px; display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong style="color: #212529; font-size: 16px;">{i}. {nombre}</strong>
                    <div style="color: #6c757d; font-size: 14px; margin-top: 4px;">
                        {grado}¬∞ {grupo} - {turno}
                    </div>
                </div>
                <div style="color: #007bff; font-size: 12px;">
                    ID: {student.get('id', 'N/A')}
                </div>
            </div>
            """

        html += """
            </div>
        </div>
        """

        return html
